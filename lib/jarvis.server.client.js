const crypto=require("crypto");const https=require("https");const JarvisClient=require("./jarvis.client.js");const{ucFirst}=require("./helpers.js");module.exports={announceClients(){this.adapter.log.info("Server has "+Object.values(this.clients).length+" connected clients.");this.emit("CLIENT_LIST",Object.values(this.clients).map(e=>{e={...e};delete e._class;return e}))},authenticate({cb:t,clientId:e},s=""){const i=this.options["authentication"+ucFirst(s||"")];const n=this.clients[e];this.authenticateClient(n,s).then(()=>{t({authenticationMethod:i,instance:this.adapter.instance,authenticated:true})}).catch(e=>{t({err:e,authenticationMethod:i,instance:this.adapter.instance,authenticated:false})})},authenticateClient(i,n=""){n="authentication"+ucFirst(n||"");const e=this.options[n];const t=this.clientsAuthenticated[i.id+(n?"-"+n:"")];if(!this.options.socketSecure||e==="none"){i.isAuthenticated=true;return Promise.resolve()}else if(e==="password"){if(t!==this.options[n+"Password"]){return Promise.reject(new Error("Authentication failed! User not logged-in!"))}this.adapter.log.debug("Authenticated client via password.");i.isAuthenticated=true;return Promise.resolve()}else if(e==="group"){i.userName=t;if(!i.userName&&!i.userId&&!this.options.webPort){return Promise.reject(new Error("Authentication failed! User not logged-in!"))}let e=Promise.resolve();if(!i.userName&&!i.userId&&this.options.webPort){e=new Promise(t=>{const s=setTimeout(()=>t(),3*1e3);this.adapter.sendTo("web.0","getUserByCookie",{cookie:i.cookie},e=>{clearTimeout(s);if(!e.error&&e.user){this.adapter.log.debug('Authenticated client via user id "'+e.user+'" using the web-adapter.');i.userId="system.user."+e.user}t()})})}return e.then(()=>this.getUsers(true)).then(e=>{const t=e.find(e=>e.id===i.userName||e.value._id===i.userId);if(!t||t.value.common.enabled!==true){this.adapter.log.debug("Authentication failed! User not valid!");throw new Error("Authentication failed! User not valid!")}this.adapter.log.debug('Verify authorizations for user "'+t.id+'"...');const s=t.value.groups;if(this.options[n+"Group"]&&Array.isArray(this.options[n+"Group"])&&this.options[n+"Group"].length>0&&!s.some(e=>this.options[n+"Group"].includes(e.value._id))){this.adapter.log.debug("Authentication failed! User not authorized!");throw new Error("Authentication failed! User not authorized!")}else if((!this.options[n+"Group"]||!Array.isArray(this.options[n+"Group"])||this.options[n+"Group"].length===0)&&userGroup.value._id!=="system.group.administrator"){this.adapter.log.debug("Authentication failed! Invalid adapter configuration for groups!");throw new Error("Authentication failed! Invalid adapter configuration for groups!")}i.isAuthenticated=true;i.userId=t.value._id;i.userName=t.id;this.adapter.log.debug('Authenticated client via username "'+i.userName+'".');return true})}return Promise.reject(new Error("Authentication failed! Invalid adapter configuration!"))},connectClient(e,t){const s=JarvisClient.getClientInformation(t);s._class=this.clients[s.id]&&this.clients[s.id]._class||null;if(!s._class){s._class=new JarvisClient(this.adapter,s);s._class.on("disconnected",()=>this.disconnectClient(s));this.clients[s.id]=s;this.announceClients();this.emit("CLIENT_NEW",{...s,_class:undefined})}const i=s.id;const n=e.id;s._class.addInstance(n,e);this.send({clientId:i,instanceId:n},"#time",Date.now());this.send({clientId:i,instanceId:n},"#version",this.adapter.version);this.send({clientId:i,instanceId:n},"#instance",this.adapter.instance);this.send({clientId:i,instanceId:n},"#client",{...s,_class:undefined});this.updateClient(this.clients[s.id]);return s},disconnectClient(e){this.clients[e.id]&&this.updateClient(this.clients[e.id],{connected:false}).then(()=>{this.clients[e.id]&&this.clients[e.id]._class.removeAllListeners();delete this.clients[e.id];this.announceClients()})},listenClient(s){s._class.on("message",(e,t)=>{t=t.toString();this.handleClientEvent({clientId:s.id,instanceId:e},t)})},ping({clientId:e,instanceId:t}){if(this.clients[e]){this.adapter.log.silly("Received ping from "+this.clients[e].ip+" ("+t+").");this.updateClient(this.clients[e]);if(this.clients[e]&&this.clients[e]._class.instances[t]){this.clients[e]._class.instances[t].alive&&clearTimeout(this.clients[e]._class.instances[t].alive);this.clients[e]._class.instances[t].alive=setTimeout(()=>this.clients[e]&&this.clients[e]._class.disconnect(t,"Client-Connection timeout"),3*60*1e3)}}},updateClient(c,e={}){e.connected=e.connected!==undefined?e.connected:true;const l={connected:{name:"Indicates client connection",role:"indicator.connected",type:"boolean",value:e.connected},ip:{name:"Client IP",role:"info.ip",type:"string",value:c.ip},id:{name:"Client ID",role:"text",type:"string",value:c.id},userAgent:{name:"Client User Agent",role:"text",type:"string",value:c.userAgent},userPlatform:{name:"Client Platform Information",role:"text",type:"json",value:c.userPlatform},userBrowser:{name:"Client Browser",role:"text",type:"string",value:c.userBrowser},lastSeen:{name:"Client Last Seen",role:"value.time",type:"number",value:Date.now()}};return new Promise(t=>{this.adapter.setObjectNotExists("clients."+c.ns,{type:"device",common:{name:c.id},native:{}},()=>{const e=Object.keys(l).map(o=>{return new Promise(s=>{const i="clients."+c.ns+"."+o;const{role:e,type:t,value:n,initial:r,subscribe:a}=l[o];this.adapter.setObjectNotExists(i,{type:"state",common:{role:e,type:t,write:false},native:{}},(e,t)=>{if(t&&r||n!==undefined){this.adapter.setState(i,typeof n==="object"?JSON.stringify(n,null,3):n,true)}s()})})});e.push(new Promise(e=>{const t="clients."+c.ns+".setTabId";this.adapter.setObjectNotExists(t,{type:"state",common:{role:"text",type:"string",write:true},native:{}},()=>e())}));e.push(new Promise(e=>{const t="clients."+c.ns+".browserConsoleInLog";this.adapter.setObjectNotExists(t,{type:"state",common:{role:"info",type:"string",write:true,def:"off",states:{off:"off",debug:"debug",info:"info",warn:"warn",error:"error"}},native:{}},()=>e())}));e.push(new Promise(e=>{const t="clients.allBrowserConsoleInLog";this.adapter.setObjectNotExists(t,{type:"state",common:{role:"info",type:"string",write:true,def:"warn",states:{off:"off",debug:"debug",info:"info",warn:"warn",error:"error"}},native:{}},()=>e())}));Promise.allSettled(e).then(t)})})},removeOutdatedClients(){this.adapter.getDevices((e,t)=>{t.forEach(n=>{this.adapter.getState(n._id+".lastSeen",(e,t)=>{const s=n._id.substr(n._id.lastIndexOf(".")+1);const i=Date.now()-7*24*3600*1e3;if(e&&e.message){this.adapter.log.warn("Error removing old devices: "+e.message)}if(!t||!t.val||t.val<i){this.adapter.log.info("Device "+s+" expired and removed.");this.adapter.delForeignObject(n._id,{recursive:true},()=>{})}})})})},handleClientEvent(e,t){try{const s=JSON.parse(t);if(s&&s.event==="message"){const{messageId:i,index:n,length:r,chunk:a}=s;this.clientsMessages[i]=this.clientsMessages[i]||{};this.clientsMessages[i][n]=a;if(Object.keys(this.clientsMessages[i]).length===r){this.emit("message",e,Object.values(this.clientsMessages[i]).join(""));delete this.clientsMessages[i]}}}catch(e){this.adapter.log.warn("Warning listening for messages from client: "+e.message+". See debug-log for more details.");this.adapter.log.debug("Event: "+t)}},handleClientMessage(i){try{const n=JSON.parse(i);let{messageId:e,command:t,params:s=[]}=n;s=Array.isArray(s)?s:[s];return{command:t,messageId:e,params:s}}catch(e){this.adapter.log.warn("Warning handling message: "+e.message+" (see debug-log for details)");this.adapter.log.debug("Message: "+i)}return null},handleClientCommand(t,s,i,e){if(s&&this[s]){const n=this.clients[t.clientId];if(n.isAuthenticated===true||["ping","authenticate","verifyLogin"].includes(s)){cb=e=>this.send(t,s,e,i);this[s]({cb:cb,command:s,...t,messageId:i},...e)}else{this.send(t,s,{err:new Error("Client is not authenticated!")},i)}}else{this.adapter.log.warn("Unknown command: "+s+" (from client "+t.clientId+" / "+t.instanceId+").")}},broadcast(e,t,s=this.clients){s=Array.isArray(s)?s:Object.keys(s);for(const i of s){this.send(i,e,t)}},send(i,n,t={},r=crypto.randomUUID(),a="message"){if(typeof i!=="object"){i={clientId:i}}if(t.err&&t.err!=="_isNull"&&t.err.name!=="_isNull"){t.err={name:t.err.name||t.err,message:t.err.message,stack:t.err.stack}}else if(t.err===null){t.err="_isNull"}const o=this.clients[i.clientId];if(o){const e=JSON.stringify(t).match(/.{1,100000}/g);const c=e.length;try{e.forEach((e,t)=>{const s={event:a,...i,messageId:r,action:n,index:t,length:c,chunk:e};o._class.send(s,i)})}catch(e){this.adapter.log.warn("Error sending message to client with ip "+o.ip+' (action "'+n+'"): '+e.message);this.adapter.log.debug("Error sending message with data: "+JSON.stringify(t))}}},verifyLogin({cb:n,clientId:r},e,a,t,o=""){o="authentication"+ucFirst(o||"");if(e==="password"){if(t!==this.options[o+"Password"]){return n({err:new Error("Authentication failed! Password incorrect!")})}this.clientsAuthenticated[r+(o?"-"+o:"")]=this.options[o+"Password"];this.adapter.log.debug("Client authenticated using password.");return n({login:true})}else if(e==="group"){if(!a||!t){return n({err:new Error("Authentication failed! Username or password incorrect!")})}this.adapter.checkPassword(a,t,e=>{if(e){this.getUsers(true).then(e=>{const t=e.find(e=>e.id===a);if(!t||t.value.common.enabled!==true){return n({err:new Error("Authentication failed! User not valid!")})}const s=!this.options[o+"Group"]||Array.isArray(this.options[o+"Group"])?this.options[o+"Group"]:this.options[o+"Group"].split(",");const i=t.value.groups;if(s&&Array.isArray(s)&&s.length>0&&!i.some(e=>s.includes(e.value._id))){return n({err:new Error("Authentication failed! User not authorized!")})}else if((!s||!Array.isArray(s)||s.length===0)&&userGroup.value._id!=="system.group.administrator"){return n({err:new Error("Authentication failed! Invalid adapter configuration for groups!")})}this.clientsAuthenticated[r+(o?"-"+o:"")]=a;this.adapter.log.debug('Client authenticated using username "'+a+'" and password.');return n({login:true})})}else{return n({err:new Error("Authentication failed! Username or password incorrect!")})}})}else{n({err:new Error("Incorrect authentication method!")})}}};