const _uuid=require("uuid").v4;const JarvisClient=require("./jarvis.client.js");module.exports={ping({clientId:e,instanceId:t}){if(this.clients[e]){this.adapter.log.silly("Received ping from "+this.clients[e].ip+" ("+t+").");this.updateClient(this.clients[e]);if(this.clients[e]&&this.clients[e]._class.instances[t]){this.clients[e]._class.instances[t].alive&&clearTimeout(this.clients[e]._class.instances[t].alive);this.clients[e]._class.instances[t].alive=setTimeout(()=>this.clients[e]&&this.clients[e]._class.disconnect(t,"Client-Connection timeout"),3*60*1e3)}}},announceClients(){this.adapter.log.info("Server has "+Object.values(this.clients).length+" connected clients.");this.emit("CLIENT_LIST",Object.values(this.clients).map(e=>{e={...e};delete e._class;return e}))},connectClient(e,t){const s=JarvisClient.getClientInformation(t);s._class=this.clients[s.id]&&this.clients[s.id]._class||null;if(!s._class){s._class=new JarvisClient(this.adapter,s);s._class.on("message",(e,t)=>{t=t.toString();this.handleClientEvent({clientId:s.id,instanceId:e},t)});s._class.on("disconnected",e=>{this.clients[s.id]&&this.updateClient(this.clients[s.id],{connected:false}).then(()=>{this.clients[s.id]&&this.clients[s.id]._class.removeAllListeners();delete this.clients[s.id];this.announceClients()})});this.clients[s.id]=s;this.announceClients();this.emit("CLIENT_NEW",{...s,_class:undefined})}const n=s.id;const i=e.id;s._class.addInstance(i,e);this.send({clientId:n,instanceId:i},"#time",Date.now());this.send({clientId:n,instanceId:i},"#client",{...s,_class:undefined});this.send({clientId:n,instanceId:i},"#version",this.adapter.version);this.updateClient(this.clients[s.id]);return s},listenClient(e){},updateClient(c,e={}){e.connected=e.connected!==undefined?e.connected:true;const o={connected:{name:"Indicates client connection",role:"indicator.connected",type:"boolean",value:e.connected},ip:{name:"Client IP",role:"info.ip",type:"string",value:c.ip},id:{name:"Client ID",role:"text",type:"string",value:c.id},userAgent:{name:"Client User Agent",role:"text",type:"string",value:c.userAgent},userPlatform:{name:"Client Platform Information",role:"text",type:"json",value:c.userPlatform},userBrowser:{name:"Client Browser",role:"text",type:"string",value:c.userBrowser},lastSeen:{name:"Client Last Seen",role:"value.time",type:"number",value:Date.now()}};return new Promise(t=>{this.adapter.setObjectNotExists("clients."+c.ns,{type:"device",common:{name:c.id},native:{}},()=>{const e=Object.keys(o).map(l=>{return new Promise(s=>{const n="clients."+c.ns+"."+l;const{role:e,type:t,value:i,initial:a,subscribe:r}=o[l];this.adapter.setObjectNotExists(n,{type:"state",common:{role:e,type:t,write:false},native:{}},(e,t)=>{if(t&&a||i!==undefined){this.adapter.setState(n,typeof i==="object"?JSON.stringify(i,null,3):i,true)}s()})})});e.push(new Promise(e=>{const t="clients."+c.ns+".setTabId";this.adapter.setObjectNotExists(t,{type:"state",common:{role:"text",type:"string",write:true},native:{}},()=>e())}));e.push(new Promise(e=>{const t="clients."+c.ns+".browserConsoleInLog";this.adapter.setObjectNotExists(t,{type:"state",common:{role:"info",type:"string",write:true,def:"off",states:{off:"off",debug:"debug",info:"info",warn:"warn",error:"error"}},native:{}},()=>e())}));e.push(new Promise(e=>{const t="clients.allBrowserConsoleInLog";this.adapter.setObjectNotExists(t,{type:"state",common:{role:"info",type:"string",write:true,def:"warn",states:{off:"off",debug:"debug",info:"info",warn:"warn",error:"error"}},native:{}},()=>e())}));Promise.allSettled(e).then(t)})})},removeOutdatedClients(){this.adapter.getDevices((e,t)=>{t.forEach(i=>{this.adapter.getState(i._id+".lastSeen",(e,t)=>{const s=i._id.substr(i._id.lastIndexOf(".")+1);const n=Date.now()-7*24*3600*1e3;if(e&&e.message){this.adapter.log.warn("Error removing old devices: "+e.message)}if(!t||!t.val||t.val<n){this.adapter.log.info("Device "+s+" expired and removed.");this.adapter.delForeignObject(i._id,{recursive:true},()=>{})}})})})},handleClientEvent(e,t){try{const s=JSON.parse(t);if(s&&s.event==="message"){const{messageId:n,index:i,length:a,chunk:r}=s;this.clientsMessages[n]=this.clientsMessages[n]||{};this.clientsMessages[n][i]=r;if(Object.keys(this.clientsMessages[n]).length===a){this.emit("message",e,Object.values(this.clientsMessages[n]).join(""));delete this.clientsMessages[n]}}}catch(e){this.adapter.log.warn("Warning listening for messages from client: "+e.message+". See debug-log for more details.");this.adapter.log.debug("Event: "+t)}},handleClientMessage(n){try{const i=JSON.parse(n);let{messageId:e,command:t,params:s=[]}=i;s=Array.isArray(s)?s:[s];return{command:t,messageId:e,params:s}}catch(e){this.adapter.log.warn("Warning handling message: "+e.message+" (see debug-log for details)");this.adapter.log.debug("Message: "+n)}return null},handleClientCommand(t,s,n,e){if(s&&this[s]){cb=e=>this.send(t,s,e,n);this[s]({cb:cb,command:s,...t,messageId:n},...e)}else{this.adapter.log.warn("Unknown command: "+s+" (from client "+t.clientId+" / "+t.instanceId+").")}},broadcast(e,t,s=this.clients){s=Array.isArray(s)?s:Object.keys(s);for(const n of s){this.send(n,e,t)}},send(n,i,t={},a=_uuid(),r="message"){if(typeof n!=="object"){n={clientId:n}}if(t.err&&t.err!=="_isNull"&&t.err.name!=="_isNull"){t.err={name:t.err.name||t.err,message:t.err.message,stack:t.err.stack}}else if(t.err===null){t.err="_isNull"}const e=JSON.stringify(t).match(/.{1,100000}/g);const l=e.length;try{e.forEach((e,t)=>{const s={event:r,...n,messageId:a,action:i,index:t,length:l,chunk:e};this.clients[n.clientId]&&this.clients[n.clientId]._class.send(s,n)})}catch(e){this.adapter.log.warn("Error sending message to client with ip "+this.clients[n.clientId].ip+' (action "'+i+'"): '+e.message);this.adapter.log.debug("Error sending message with data: "+JSON.stringify(t))}}};