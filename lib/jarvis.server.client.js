const _uuid=require("uuid").v4;const JarvisClient=require("./jarvis.client.js");module.exports={announceClients(){this.adapter.log.info("Server has "+Object.values(this.clients).length+" connected clients.");this.emit("CLIENT_LIST",Object.values(this.clients).map(e=>{e={...e};delete e.adapter;delete e.socket;delete e.alive;delete e._events;delete e._eventsCount;delete e._maxListeners;return e}))},connectClient(e,t){const s=new JarvisClient(this.adapter,e);const n=s.init(t);this.clients[n.id]=s;this.updateClient(this.clients[n.id]);return n},listenClient(t){const e=this.clients[t.id];e.listen();e.on("message",e=>{e=e.toString();this.handleClientEvent(t.id,e)});e.on("disconnected",e=>{this.clients[t.id]&&this.updateClient(this.clients[t.id],{connected:false}).then(()=>{delete this.clients[t.id];this.announceClients()})});this.announceClients();this.emit("CLIENT_NEW",t);this.send(t.id,"#time",Date.now());this.send(t.id,"#client",t);this.send(t.id,"#version",this.adapter.version)},updateClient(o,e={}){e.connected=e.connected!==undefined?e.connected:true;const c={connected:{name:"Indicates client connection",role:"indicator.connected",type:"boolean",value:e.connected},ip:{name:"Client IP",role:"info.ip",type:"string",value:o.ip},id:{name:"Client ID",role:"text",type:"string",value:o.id},userAgent:{name:"Client User Agent",role:"text",type:"string",value:o.userAgent},userPlatform:{name:"Client Platform Information",role:"text",type:"json",value:o.userPlatform},userBrowser:{name:"Client Browser",role:"text",type:"string",value:o.userBrowser},lastSeen:{name:"Client Last Seen",role:"value.time",type:"number",value:Date.now()}};return new Promise(t=>{this.adapter.setObjectNotExists("clients."+o.ns,{type:"device",common:{name:o.id},native:{}},()=>{const e=Object.keys(c).map(l=>{return new Promise(s=>{const n="clients."+o.ns+"."+l;const{role:e,type:t,value:i,initial:a,subscribe:r}=c[l];this.adapter.setObjectNotExists(n,{type:"state",common:{role:e,type:t,write:false},native:{}},(e,t)=>{if(t&&a||i!==undefined){this.adapter.setState(n,typeof i==="object"?JSON.stringify(i,null,3):i,true)}s()})})});e.push(new Promise(e=>{const t="clients."+o.ns+".setTabId";this.adapter.setObjectNotExists(t,{type:"state",common:{role:"text",type:"string",write:true},native:{}},()=>e())}));Promise.allSettled(e).then(t)})})},removeOutdatedClients(){this.adapter.getDevices((e,t)=>{t.forEach(i=>{this.adapter.getState(i._id+".lastSeen",(e,t)=>{const s=i._id.substr(i._id.lastIndexOf(".")+1);const n=Date.now()-7*24*3600*1e3;if(e&&e.message){this.adapter.log.warn("Error removing old devices: "+e.message)}if(!t||!t.val||t.val<n){this.adapter.log.info("Device "+s+" expired and removed.");this.adapter.delForeignObject(i._id,{recursive:true},()=>{})}})})})},handleClientEvent(e,t){try{const s=JSON.parse(t);if(s&&s.event==="message"){const{messageId:n,index:i,length:a,chunk:r}=s;this.clientsMessages[n]=this.clientsMessages[n]||{};this.clientsMessages[n][i]=r;if(Object.keys(this.clientsMessages[n]).length===a){this.emit("message",e,Object.values(this.clientsMessages[n]).join(""));delete this.clientsMessages[n]}}}catch(e){this.adapter.log.warn("Warning listening for messages from client: "+e.message+". See debug-log for more details.");this.adapter.log.debug("Event: "+t)}},handleClientMessage(n){try{const i=JSON.parse(n);let{messageId:e,command:t,params:s=[]}=i;s=Array.isArray(s)?s:[s];return{command:t,messageId:e,params:s}}catch(e){this.adapter.log.warn("Warning handling message: "+e.message+" (see debug-log for details)");this.adapter.log.debug("Message: "+n)}return null},handleClientCommand(t,s,n,e){if(s&&this[s]){cb=e=>this.send(t,s,e,n);this[s]({cb:cb,command:s,clientId:t,messageId:n},...e)}else{this.adapter.log.warn("Unknown command: "+s+" (from client "+t+").")}},broadcast(e,t,s=this.clients){s=Array.isArray(s)?s:Object.keys(s);for(const n of s){this.send(n,e,t)}},send(n,i,t={},a=_uuid(),r="message"){if(t.err){t.err={name:t.err.name||t.err,message:t.err.message,stack:t.err.stack}}else if(t.err===null){t.err="_isNull"}const e=JSON.stringify(t).match(/.{1,100000}/g);const l=e.length;try{e.forEach((e,t)=>{const s={event:r,clientId:n,messageId:a,action:i,index:t,length:l,chunk:e};this.clients[n]&&this.clients[n].send(s,n)})}catch(e){this.adapter.log.warn("Error sending message to client with ip "+this.clients[n].ip+' (action "'+i+'"): '+e.message);this.adapter.log.debug("Error sending message with data: "+JSON.stringify(t))}}};