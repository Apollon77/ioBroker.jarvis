const crypto=require("crypto");module.exports={loadNotifications(){return new Promise((e,a)=>{this.adapter.getState("notifications",(t,i)=>{try{this.notifications=i&&i.val&&JSON.parse(i.val)||[];e()}catch(t){this.adapter.log.error("Error initially loading notifications: "+t.message);a(t.message)}})})},handleNotification(t,i){if(t&&t.endsWith(".addNotification")&&i&&i.val){this.adapter.setState("addNotification","",true);this.addNotification(i.val)}else if(t&&t.endsWith(".notifications")){try{this.notifications=JSON.parse(i?i.val:"[]")}catch(t){this.adapter.log.warn(t.message)}}},addNotification(t){try{const s=t.indexOf("{")>-1&&t.indexOf("}")>-1?JSON.parse(t):{title:t};s.message=s.message?s.message.replace(/(\r\n|\r|\n)/g,"<br />"):undefined;s.id=crypto.randomUUID();s.ts=s.ts||Date.now();if(s.devices){s.devices=Array.isArray(s.devices)?s.devices:[s.devices]}if(s.state!=="delete"){const e=this.settings.maxNotifications||500;this.notifications.push(s);this.adapter.setState("notifications",JSON.stringify(this.notifications.slice(-(e+1))),true)}const i=s.devices||Object.keys(this.clients);i.forEach(e=>{const a=this.clients[e];this.adapter.getState("clients."+a.ns+".connected",(t,i)=>{if(!t&&i&&i.val===true){this.adapter.log.debug("Client with ID "+e+" online. Notification delivered.");this.send({clientId:e},"notification",s)}else{a.unreadNotifications.push(s);this.adapter.log.debug("Client with ID "+e+" not online, thus saving notification for later ("+a.unreadNotifications.length+" saved).")}})})}catch(t){this.adapter.log.error("Error adding notification: "+t.message)}}};